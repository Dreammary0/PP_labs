 /* Интегрирование - основные моменты:
    Функция f(x) - это функция, которую мы интегрируем. В данном случае это простая квадратичная функция.

    Последовательное интегрирование (integrate):
        Используется метод прямоугольников для численного интегрирования.
        Цикл проходит по всем разбиениям и суммирует значения функции.

    Параллельное интегрирование (integrateParallel):
        Используется OpenMP для распараллеливания вычислений.
        Каждый поток обрабатывает свою часть данных, а затем результаты суммируются в критической секции.

    Измерение времени:
        Время выполнения измеряется с помощью omp_get_wtime().
        Для каждого количества потоков (от 1 до максимального) выполняется несколько экспериментов для усреднения времени.

    Результаты (время выполнения и значение интеграла) выводятся в консоль и записываются в файл output.csv. */


#include <iostream>
#include <chrono>
#include <omp.h>  // Библиотека OpenMP для параллельного программирования
#include <thread> // Для работы с потоками
#include <fstream> // Для работы с файлами
#include "vector"  // Для использования std::vector

// Константы для количества разбиений и количества экспериментов
const double N = 100'000'000'0; // Количество разбиений для численного интегрирования
const size_t experiments = 10; // Количество экспериментов для усреднения времени

// Функция, которую мы интегрируем
double f(double x)
{
    return x * x - 1; // Пример функции: f(x) = x^2 - 1
}

// Последовательное интегрирование методом прямоугольников
double integrate(double a, double b)
{
    double sum = 0; // Сумма значений функции
    double dx = (b - a) / N; // Шаг разбиения

    // Цикл по всем разбиениям
    for (int i = 0; i < N; i++)
    {
        sum += f(a + i * dx); // Добавляем значение функции в текущей точке
    }

    return dx * sum; // Возвращаем результат интегрирования
}

// Параллельное интегрирование с использованием OpenMP
double integrateParallel(double a, double b)
{
    double sum = 0; // Общая сумма значений функции
    double dx = (b - a) / N; // Шаг разбиения

#pragma omp parallel // Начало параллельной секции
    {
        unsigned t = omp_get_thread_num(); // Номер текущего потока
        unsigned T = omp_get_num_threads(); // Общее количество потоков
        double threadSum = 0; // Локальная сумма для текущего потока

        // Каждый поток обрабатывает свою часть данных
        for (size_t i = t; i < N; i += T)
        {
            threadSum += f(a + i * dx); // Добавляем значение функции в текущей точке
        }

#pragma omp critical // Критическая секция для безопасного обновления общей суммы
        {
            sum += threadSum; // Добавляем локальную сумму к общей
        }
    }

    return dx * sum; // Возвращаем результат интегрирования
}

int main()
{
    std::ofstream output("../output.csv"); // Открываем файл для записи результатов

    if (!output.is_open()) // Проверяем, удалось ли открыть файл
    {
        std::cout << "Couldn't open file!\n";
        return -1;
    }

    // Определяем количество потоков, поддерживаемых системой
    const size_t threadCount = std::thread::hardware_concurrency();
    std::cout << "Number of available threads:  " << threadCount << "\n";

    // Границы интегрирования
    const double a = 0;
    const double b = 1;

    // Векторы для хранения времени выполнения и результатов
    std::vector<size_t> times(threadCount + 1); // Время для каждого количества потоков
    std::vector<double> values(threadCount + 1); // Результаты интегрирования

    double t1 = 0, t2 = 0; // Переменные для измерения времени
    double totalTime = 0; // Общее время выполнения

    double result = 0; // Результат интегрирования

    // Последовательное интегрирование
    for(size_t i = 0; i < experiments; ++i){
        double t1 = omp_get_wtime(); // Начало измерения времени
        result = integrate(a, b); // Вызов последовательного интегрирования
        double t2 = omp_get_wtime(); // Конец измерения времени
        totalTime += t2 - t1; // Суммируем время выполнения
    }

    // Сохраняем среднее время и результат для последовательного выполнения
    times[0] = 1000 * totalTime / experiments; // Среднее время в миллисекундах
    values[0] = result; // Результат интегрирования

    // Параллельное интегрирование с разным количеством потоков
    for (std::size_t i = 1; i <= threadCount; i++)
    {
        totalTime = 0; // Сбрасываем общее время
        for(size_t trial = 0; trial < experiments; trial++){
            omp_set_num_threads(i); // Устанавливаем количество потоков
            t1 = omp_get_wtime(); // Начало измерения времени
            result = integrateParallel(a, b); // Вызов параллельного интегрирования
            t2 = omp_get_wtime(); // Конец измерения времени
            totalTime += t2 - t1; // Суммируем время выполнения
        }

        // Сохраняем среднее время и результат для текущего количества потоков
        times[i] = 1000 * totalTime / experiments; // Среднее время в миллисекундах
        values[i] = result; // Результат интегрирования
    }

    // Вывод результатов в консоль и файл
    std::cout << "thread\t duration\t value\n";
    output << "thread,duration\n";

    for(size_t i = 0; i <= threadCount; i++){
        std::cout << i << "\t " << times[i] << "\t\t " << values[i] << "\n"; // Вывод в консоль
        output << i << "," << times[i] << "\n"; // Запись в файл
    }

    output.close(); // Закрываем файл
    return 0;
}